<!DOCTYPE html>
<html lang="fr-FR" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
		<meta charset="iso-8859-1" />
		<title>Retourner plusieurs valeurs d'une méthode en C#</title>
		<link rel="shortcut icon" href="/wwwroot/favicon.ico" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name="language" content="fr" />
		<meta name="keywords" content="" />
		<meta name="description" content="Retourner plusieurs valeurs d'une méthode en C#" />
		<meta name="author" content="Adrien Torris" />
		<meta name="robots" content="index,follow" />
		<meta name="generator" content="SiteUp! 0.1" />
		<link rel="alternate" href="https://adrientorris.github.io/fr/csharp/retourner-plusieurs-valeurs-de-sortie-methode-csharp.html" hreflang="fr-fr" />
		<link rel="alternate" href="https://adrientorris.github.io/csharp/return-multiple-values-from-function.html" hreflang="en-en" />
		<link href="/wwwroot/css/style.css" rel="stylesheet" />
	</head>
	<body>
		<div id="main_ctn">
			<header>
				<div id="header-content">
					<h2>Blog</h2>
					<ul id="flags_wrapper">
						<li class="cur"><img src="wwwroot/images/french.png" alt="" title="" /></li>
						<li><a href="https://adrientorris.github.io/csharp/return-multiple-values-from-function.html" title=""><img src="wwwroot/images/english.jpg" alt="" title="" /></a></li>
					</ul>
				</div>
			</header>
			<div id="arianne_wrapper">
				<ul>
					<li><a href="https://adrientorris.github.io/fr/index.html" title="">Accueil</a></li>
					<li>C#</li>
					<li class="active"><a href="https://adrientorris.github.io/fr/csharp/retourner-plusieurs-valeurs-de-sortie-methode-csharp.html" title="Retourner plusieurs valeurs d'une méthode en C#">Retourner plusieurs valeurs d'une méthode en C#</a></li>
				</ul>
			</div>
			<div id="post_ctn">
				<h1>Méthode renvoyant plusieurs valeurs en C#</h1>
				<p>Il y a plusieurs manières en C# d'implémenter une méthode renvoyant plusieurs valeurs. En voici quelque-unes, avec autant d'information que possible.</p>
				<ul>
					<li>
				<span class="step_number">1</span>
				<h2>Utiliser une classe</h2>
				Cette méthode, probablement la plus courante, est d'utiliser une classe comme valeur de retour. Vous êtes ainsi totalement libre de retourner ce que bon vous semble, puisque c'est vous qui définissez entièrement l'objet qui sera retourné.</p>
<pre><code class="csharp">
public sealed class MyReturnContainer
{
	public Guid GuidValue { get; }
	
	public string StringValue { get; }
	
	public int IntValue { get; }
	
	public MyReturnContainer(Guid g, string s, int i){
		GuidValue = g;
		StringValue = s;
		IntValue = i;
	}
}
</code></pre>
<pre><code class="csharp">
public class AnotherClassSomewhereInYourCode
{
	public AnotherClassSomewhereInYourCode()
	{ }
	
	public MyReturnContainer GetMultipleValues(){
		return new MyReturnContainer(Guid.NewGuid(), "string value", 1);
	}
}
</code></pre>
				<p>
					<h3>Avantages :</h3>
					<ul>
						<li>Flexibilité totale</li>
						<li>Supporte l'asynchronisme</li>
					</ul>
					<h3>Inconvénients :</h3>
					<ul>
						<li>Les classes sont de type référence (moins performant que le type valeur)</li>
						<li>Si la classe n'a pas de vrai sens métier ou n'est utilisée qu'une seule fois, cela peut alourdir votre modèle inutilement</li>
					</ul>
				</p>
				</li>
				<li>
					<span class="step_number">2</span>
					<h2>Utiliser les paramètres de sortie (out)</h2>
					<p>Les paramètres de sortie permettent de déclarer qu'une méthode a une, ou plusieurs valeurs de sortie en plus de sa valeur de retour.</p>
					<p>Un paramètre out indique au compilateur que l'objet ne sera initialisé qu'à l'intérieur de la fonction, un paramètre out ne peut donc être qu'une valeur de sortie car sa valeur ne peut pas être initialisée en amont. D'autre part, une méthode ayant des paramètres out devra obligatoirement leur attribuer une valeur à tous. Une méthode ayant des paramètres out non-assignés engendrera une erreur de compilation.</p>
<pre><code class="csharp">
Guid myGuid = Guid.Empty;
string myString = string.Empty;
int myInt = 0;

public bool GetMultipleValues(out Guid g, out string s, out int i){
	g = Guid.NewGuid();
	s = "string value";
	i = 1;
	return true;
}

bool ret = GetMultipleValues(out myGuid, out myString, out myInt);

Console.WriteLine(myString); // "string value"
</code></pre>
					<p>A noter qu'un paramètre out peut être nullable.</p>
<pre><code class="csharp">
public bool TryCreateSomething(string param1, string param2, bool param3, out Guid? id){
	id = null;
	// do something
	return true;
}
</code></pre>
					<p>Enfin, avec C# 7.0, les paramètres se sortie n'ont plus à être déclarées avant leur passage en paramètres mais peuvent l'être à la volée, comme ceci :</p>
<pre><code class="csharp">
public void PrintCoordinates(Point p)
{
    p.GetCoordinates(out int x, out int y);
    Console.WriteLine($"({x}, {y})");
}
</code></pre>
					<p>
						<h3>Avantages :</h3>
						<ul>
							<li>Flexibilité</li>
						</ul>
						<h3>Inconvénients :</h3>
						<ul>
							<li>Ne supporte pas l'asynchronisme</li>
							<li>Obligation d'assigner une valeur, même nulle</li>
						</ul>
					</p>
				</li>
				<li>
					<span class="step_number">3</span>
					<h2>Utiliser les paramètres de sortie par référence (ref)</h2>
					<p>Passer un ou plusieurs paramètres par référence a pour effet que toute modification de valeur qui sera effectuée au sein d'une méthode sera répercutée sur la variable d'origine, en dehors de la méthode.</p>
					<p>Contrairement aux paramètres de sortie (out), tout paramètre passé en référence à une méthode doit être préalablement initialisé mais ne doit pas forcemment voir une valeur lui être assignée par cette même méthode.</p>
					<p>Un paramètre ref ayant une valeur avant-même l'exécution d'une méthode, on dit que c'est un paramètre double-sens (two-ways), car sa valeur peut être utilisée au sein d'une méthode, même si cette dernière ne lui a encore rien assigné.</p>
<pre><code class="csharp">
string message = "Hello";

public void AlterMyMessage(ref string message){
	message = "Hi there !";
}

Console.WriteLine(message); // "Hello"
AlterMyMessage(ref message);
Console.WriteLine(message); // "Hi there !"
</code></pre>
					<p>
						<h3>Avantages :</h3>
						<ul>
							<li>Flexibilité</li>
							<li>Double-sens</li>
						</ul>
						<h3>Inconvénients :</h3>
						<ul>
							<li>Ne supporte pas l'asynchronisme</li>
						</ul>
					</p>
				</li>
				<li>
					<span class="step_number">4</span>
					<h2>Les Tuple</h2>
					<p>Apparus avec le Framework .NET 4.0, les Tuple permettent de créer des objets sur-mesures et complexes sans pour autant avoir à déclarer une classe. Ils peuvent contenir autant de paramètres que vous le souhaitez (le framework .NET pends en charge jusqu'à 7 éléments, mais vous pouvez outrepasser cette limitation en imbriquant des Tuple dans la propriété Rest d'un Tuple), de tout type. A leur utilisation, ces paramètres seront nommés Item<i>X</i>, <i>X</i> étant leur position (Item1 pour le premier paramètre, Item2 pour le deuxième, etc).</p>
<pre><code class="csharp">
class TupleExample
{
    static void Main()
    {
        // Instanciation d'un Tuple à 3 paramètres
		
        Tuple<int, string, bool> tuple = new Tuple<int, string, bool>(10, "string value", true);
		
        // Accès aux propriétés du Tuple créé
		
        if (tuple.Item1 == 10)
        {
            Console.WriteLine(tuple.Item1);
        }
		
        if (tuple.Item2 == "string")
        {
            Console.WriteLine(tuple.Item2);
        }
		
        if (tuple.Item3)
        {
            Console.WriteLine(tuple.Item3);
        }
    }
}
</code></pre>
					<p>Techniquement, un Tuple est une classe qui fournit des méthodes statiques pour créer des instances.</p>
					<p>Si cet objet s'avère extrêmement pratique et utile dans bon nombre de cas, il est à noter qu'il est tout de même à utiliser avec parcimonie, n'étant pas toujours facile à maintenir dans le temps. En effet, il est parfois difficile lorsqu'on repasse sur une méthode 2 ans après l'avoir écrite, de se souvenir à quoi correspondent les propriétés Item4, Item5 et Item6 ... Cela dit, il semble que ce ne sera pas une limitation encore longtemps, comme l'atteste cette <a href="https://github.com/dotnet/roslyn/issues/347" title="" target="_Blank">issue GitHub</a>. Qui plus est, si vous décidez d'ajouter un paramètre en deuxième position, alors les noms de tous les paramètres suivants seront impactés.</p>
					<p>
						<h3>Avantages :</h3>
						<ul>
							<li>Evite d'alourdir le modèle inutilement</li>
							<li>Flexibilité totale</li>
							<li>Supporte l'asynchronisme</li>
						</ul>
						<h3>Inconvénients :</h3>
						<ul>
							<li>Dénomination abstraite des propriétés</li>
							<li>Maintenabilité</li>
							<li>Performance (type référence)</li>
						</ul>
					</p>
				</li>
				<li>
					<span class="step_number">5</span>
					<h2>Utiliser une entrée de dictionnaire (KeyValuePair)</h2>
<pre><code class="csharp">
class KeyValuePairExample
{
    static void Main()
    {
        KeyValuePair<int, string> kvp = GetKeyValuePair();
    }
	
	KeyValuePair<int, string> GetKeyValuePair(){
		return new KeyValuePair<int, string>(1, "string value");
	}
}
</code></pre>
					<p>
						<h3>Avantages :</h3>
						<ul>
							<li>Facilité d'utilisation (classe implémentant déjà certaines méthodes de requêtage, et autres)</li>
							<li>Supporte l'asynchronisme</li>
							<li>Unicicité des coupes clé/valeur (en cas de dictionnaire)</li>
						</ul>
						<h3>Inconvénients :</h3>
						<ul>
							<li>Performance (moins performant qu'un Tuple de 2 paramètres, ou qu'une structure)</li>
						</ul>
					</p>
				</li>
				<li>
					<span class="step_number">6</span>
					<h2>Utiliser une structure (struct)</h2>
					<p>Les structures sont des alternatives aux classes, et sont de type valeur, contrairement aux classes qui sont de type référence. Si les structures ont bien plus de limitations que les classes, elles sont bien plus performantes, raison pour laquelle il est préférable d'utiliser des structures quand vous le pouvez, surtout si la structure de données en question aura un volume d'instanciations important.</p>
					<p>Principales limitations des structures par rapport aux classes :
						<ul>
							<li>Héritage impossible</li>
							<li>Toutes les propriétés doivent avoir une valeur</li>
							<li>Les constructeurs sans paramètres sont impossibles (il avaient été ajouté dans C# 6 mais retirés depuis, et ne sont à priori pas à l'étude pour C# 7)</li>
							<li>Tout constructeur doit assigner une valeur à chaque propriété de la structure (sinon la valeur par défaut du type sera assignée)</li>
						</ul>
					</p>
<pre><code class="csharp">
public struct Point 
{
   public int x, y;
   
   // Constructor:
   public Point(int x, int y) 
   {
      this.x = x;
      this.y = y;
   }
   
   // Override the ToString method:
   public override string ToString()
   {
      return(String.Format("({0},{1})", x, y));   
   }
}
</code></pre>
					<p>
						<h3>Avantages :</h3>
						<ul>
							<li>Type valeur (performance++)</li>
							<li>Simplicité</li>
							<li>Supporte l'asynchronisme</li>
						</ul>
						<h3>Inconvénients :</h3>
						<ul>
							<li>Rigidité de l'objet</li>
						</ul>
					</p>
				</li>
				</ul>
				<div id="crdny">
					posté le 09/10/2016
				</div>
				<div id="tags_wrapper">
					<ul>
						<li>C#</li>
						<li>Csharp</li>
					</ul>
				</div>
				<div id="refs_wrapper">
					<ul>
						<li><a href="https://msdn.microsoft.com/fr-fr/library/s1ax56ch(v=vs.90).aspx" title="Types valeur (Référence C#)" target="_Blank">Types valeur (Référence C#)</a></li>
						<li><a href="https://msdn.microsoft.com/fr-fr/library/490f96s2(v=vs.90).aspx" title="Types référence (Référence C#)" target="_Blank">Types référence (Référence C#)</a></li>
						<!--<li><a href="" title="" target="_Blank"></a></li>
						<li><a href="" title="" target="_Blank"></a></li>
						<li><a href="" title="" target="_Blank"></a></li>-->
					</ul>
				</div>
            </div>
			<footer>
			</footer>
		</div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js" type="text/javascript"></script>
		<script src="/wwwroot/js/Infra.js" type="text/javascript"></script>
		<link type="text/css" rel="stylesheet" href="/wwwroot/lib/highlight/styles/vs.css"/>
		<script type="text/javascript" src="/wwwroot/lib/highlight/highlight.pack.js"></script>
		<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85948839-1', 'auto');
  ga('send', 'pageview');

</script>
	</body>
</html>