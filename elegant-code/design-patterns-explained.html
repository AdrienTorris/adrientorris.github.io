<!DOCTYPE html>
<html lang="en-US" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
		<title>Design Patterns explained</title>
		<link rel="shortcut icon" href="/wwwroot/favicon.ico" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name="language" content="en" />
		<meta name="keywords" content="Design Patterns,design pattern,Creational Design Patterns,structural design patterns,behavioral design patterns" />
		<meta name="description" content="Design Patterns explained" />
		<meta name="author" content="Adrien Torris" />
		<meta name="robots" content="index,follow" />
		<meta name="generator" content="No404! 0.1" />
		<link rel="alternate" href="https://adrientorris.github.io/elegant-code/design-patterns-explained.html" hreflang="en-en" />
		<link href="/wwwroot/css/style.css" rel="stylesheet" />
	</head>
	<body>
		<div id="main_ctn" class="post_ctn">
			<header>
				<div id="header-content">
					<h2>Blog</h2>
				</div>
			</header>
			<div id="arianne_wrapper">
				<ul>
					<li><a href="https://adrientorris.github.io/index.html" title="">Home</a></li>
					<li>elegant code</li>
					<li class="active"><a href="https://adrientorris.github.io/elegant-code/design-patterns-explained.html" title="Design Patterns explained">Design Patterns explained</a></li>
				</ul>
			</div>
			<div id="post_ctn">
            </div>
			<div id="post_ctn">
				<h1>Design Patterns explained</h1>
				<p></p>
				<h2>Types of Design Patterns</h2>
				<ul>
					<li>
						<a href="#creational_design_pattern_title" title="">Creational</a>
						<ul>
							<li><a href="#simple_factory_ttl" title="">Simple Factory</a></li>
							<li><a href="#factory_method_ttl" title="">Factory Method</a></li>
							<li><a href="#abstract_factory_ttl" title="">Abstract Factory</a></li>
							<li><a href="#" title="">Builder</a></li>
							<li><a href="#" title="">Prototype</a></li>
							<li><a href="#" title="">Singleton</a></li>
						</ul>
					</li>
					<li>
						<a href="#" title="">Structural</a>
						<ul>
							<li><a href="#" title="">Adapter</a></li>
							<li><a href="#" title="">Bridge</a></li>
							<li><a href="#" title="">Composite</a></li>
							<li><a href="#" title="">Decorator</a></li>
							<li><a href="#" title="">Facade</a></li>
							<li><a href="#" title="">Flyweight</a></li>
							<li><a href="#" title="">Proxy</a></li>
						</ul>
					</li>
					<li>
						<a href="#" title="">Behavioral</a>
						<ul>
							<li><a href="#" title="">Chain of Responsibility</a></li>
							<li><a href="#" title="">Command</a></li>
							<li><a href="#" title="">Iterator</a></li>
							<li><a href="#" title="">Mediator</a></li>
							<li><a href="#" title="">Memento</a></li>
							<li><a href="#" title="">Observer</a></li>
							<li><a href="#" title="">Visitor</a></li>
							<li><a href="#" title="">Strategy</a></li>
							<li><a href="#" title="">State</a></li>
							<li><a href="#" title="">Template Method</a></li>
						</ul>
					</li>
				</ul>
				<h2 id="creational_design_pattern_title">Creational Design Patterns</h2>
				<p>A creational design pattern is focused towards how to instantiate an object or group of related objects.</p>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, creational design patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</blockquote>
				<h3 id="simple_factory_ttl">Simple Factory</h3>
				<p>Wikipedia says :</p>
				<blockquote>In object-oriented programming (OOP), a factory is an object for creating other objects – formally a factory is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be "new".</blockquote>
				<p>In plain words, a factory in its simplest form (it's also exists abstract factory pattern and method factory pattern) is a class which has a method that returns differents type of object.</p>
				<p>Real world example :<p>
				<p>Consider you are building vehicles (like cars, motorbikes, trucks and others), it would be painfull if each time you need to put the wheels on the vehicle you need to think about it and start making the new wheels from the start. Instead you get them made from a factory.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;Contract each wheel for a vehicle have to respect
&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
public interface IVehicleWheel{
	
	int GetWidth();
	int GetDiameter();
	
}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;A wheel for a car
&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
public class CarWheel : IVehicleWheel {

	&#47;&#47;&#47;&#32;&#60;summary&#62;
	&#47;&#47;&#47;&#32;Width of the wheel in inches
	&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
	public int Width { get; }
	
	/// <summary>
	/// Diameter of the wheel in inches
	/// </summary>
	public int Diameter { get; }
	
	/// <summary>
	/// New instance of a car wheel
	/// </summary>
	public CarWheel(int width, int diameter) {
	
		Width = width;
		Diameter = diameter;
		
	}
	
	public int GetWidth() &#61;&#62; Width;
	
	public int GetDiameter() &#61;&#62; Diameter;
	
}

/// <summary>
/// Class to instanciate all the wheels you need
/// </summary>
public static class WheelFactory {

	public static IVehicleWheel MakeCarWheel(int width, int diameter) &#61;&#62; new CarWheel(width, diameter);

}
</code></pre>
				<p>And then it can be used as :</p>
<pre><code class="csharp">
IVehicleWheel wheel = WheelFactory.MakeCarWheel(15, 30);
</code></pre>
				<p>When to use it ?<p>
				<p>When creating an object isn't just a few assignements but involves some business logic, it makes sense to put the logic in a dedicated factory instead of repeating the code everywhere.</p>
				<h3 id="factory_method_ttl">Factory Method</h3>
				<p>Wikipedia says :</p>
				<blockquote>In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.</blockquote>
				<p>In plain words, a Factory Method provides a way to delegate the instanciation logic to subclasses. It defines an interface for creating an object but let's his subclasses implement this interface and decide which class to instanciate.</p>
				<p>Real world example :<p>
				<p>Consider a football player, it's impossible for one person to be very good in each game position, so you have to delegate some parts of the game to others players.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
#region Skills

public abstract class Skill
{

}

public class Acrobat : Skill {

}

public class Dribbler : Skill {

}

public class DistanceShooter : Skill {

}

public class Speedster : Skill {

}

public class Tackling : Skill {

}

public class Tactician : Skill {

}

public class ClinicalFinisher : Skill {

}

public class Strenght : Skill {

}

public class Playmaker : Skill {

}

public class Engine : Skill {

}

public class Reflex : Skill {

}

public class Tall : Skill {

}

public class Springiness : Skill {

}

public class ExtremeConcentration : Skill {

}

#endregion

#region Players

public abstract class Player()
{
	public List&#60;Skill&#62; Skills { get; protected set;}
	
	// Factory Method
    public abstract void CreateSkills();

	public Player() {
		
		CreateSkills();
		
	}
}

public class Defender : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new Strenght());
		Skills.Add(new Tackling());
		Skills.Add(new Tall());
	
	}
	
}

public class Midfielder : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new Engine());
		Skills.Add(new Playmaker());
		Skills.Add(new Tactician());
	
	}
	
}

public class Forward : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new ClinicalFinisher());
		Skills.Add(new Speedster());
		Skills.Add(new Dribbler());
		Skills.Add(new Acrobat());
	
	}
	
}

public class GoalKeeper : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new Reflex());
		Skills.Add(new Tall());
		Skills.Add(new Springiness());
		Skills.Add(new ExtremeConcentration());
	
	}
	
}

#endregion
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    /// <summary>
    /// Entry point into console application.
    /// </summary>
    static void Main()
    {
	  // Create a list of players
      List<Player> players = new List<Player>();
	  players.Add(new GoalKeeper());
	  players.Add(new Defender());
	  players.Add(new Midfielder());
	  players.Add(new Forward());
 
      // Display player skills
      foreach (Player player in players)
      {
        Console.WriteLine("\n" + player.GetType().Name + "--");
        foreach (Skill skill in player.Skills)
        {
          Console.WriteLine(" " + skill.GetType().Name);
        }
      }
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>When there is some generic processing in a class but you doesn't know what exact subclass it might need, so you let the child class decide.</p>
				<h3 id="abstract_factory_ttl">Abstract Factory</h3>
				<p>Wikipedia says :</p>
				<blockquote>The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes</blockquote>
				<p>In plain words, an abstract factory is a factory of factories. It's a class that groups the individual but related/dependent factories together without specifying their concrete classes. </p>
				<p>Real world example :<p>
				<p>To stay in the football world, we still have our different kind of players with their own skills, let consider now the coaches. The differents players doesn't need the same coach to progress. A goalkeeper needs a specific coach to his position, as a forward player needs some coaches to work on his shoot, his dribble and his velocity. So as we have different kind of players, we have different kinf of instructors with their specialities and as you can see, there is a dependency between the players and the coaches.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
#region Coachs

public abstract class Coach {

}

public class GoalKeeperCoach : Coach {
}

public class DribbleCoach : Coach {
}

public class ShootCoach : Coach {
}

public class TacklingCoach : Coach {
}

public class TacticianCoach : Coach {
}

public class PassCoach : Coach {
}

public class MuscleDevelopmentCoach : Coach {
}

#endregion

#region Skills

public abstract class Skill
{

}

public class Acrobat : Skill {

}

public class Dribbler : Skill {

}

public class Shooter : Skill {

}

public class DistanceShooter : Skill {

}

public class Speedster : Skill {

}

public class Tackling : Skill {

}

public class Tactician : Skill {

}

public class ClinicalFinisher : Skill {

}

public class Strenght : Skill {

}

public class Playmaker : Skill {

}

public class Engine : Skill {

}

public class Reflex : Skill {

}

public class Tall : Skill {

}

public class Springiness : Skill {

}

public class ExtremeConcentration : Skill {

}

public class ClinicalPasser : Skill {

}

#endregion

#region Factories

public abstract class PlayerFactory {
	public abstract Player CreatePlayer();
	public abstract List&#60;Coach&#62; CreateCoachs();
}

public class GoalKeeperFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills = new List&#60;Skill&#62;();
		player.Skills.Add(new Tall());
		player.Skills.Add(new Reflex());
		player.Skills.Add(new ExtremeConcentration());
		player.Skills.Add(new Springiness());
		return player;
	
	}
	
	public override List<Coach> CreateCoachs() {
		List<Coach> ret = new List<Coach>();
		ret.Add(new GoalKeeperCoach());
		return ret;
	}

}

public class DefenderFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills.Add(new Strenght());
		player.Skills.Add(new Tall());
		player.Skills.Add(new Tackling());
		return player;
	
	}
	
	public override List<Coach> CreateCoachs() {
		List<Coach> ret = new List<Coach>();
		ret.Add(new TacklingCoach());
		ret.Add(new MuscleDevelopmentCoach());
		return ret;
	}

}

public class MidfielderFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills.Add(new Dribble());
		player.Skills.Add(new Tactician());
		player.Skills.Add(new Tackling());
		player.Skills.Add(new ClinicalPasser());
		player.Skills.Add(new Playmaker());
		return player;
	
	}
	
	public override List<Coach> CreateCoachs() {
		List<Coach> ret = new List<Coach>();
		ret.Add(new TacklingCoach());
		ret.Add(new DribbleCoach());
		ret.Add(new PassCoach());
		ret.Add(new TacticianCoach());
		return ret;
	}

}

public class ForwardFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills.Add(new Speedster());
		player.Skills.Add(new Acrobat());
		player.Skills.Add(new Shooter());
		player.Skills.Add(new ClinicalFinisher());
		player.Skills.Add(new Dribble());
		return player;
	
	}
	
	public override List<Coach> CreateCoachs() {
		List<Coach> ret = new List<Coach>();
		ret.Add(new ShootCoach());
		ret.Add(new DribbleCoach());
		return ret;
	}

}

#endregion

#region Players

public abstract class Player()
{
	public List<Skill> Skills { get; set;}
	
	public abstract string GetDescription();
}

public class Defender : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a defender, I have {Skills.Count} skills");
	
}

public class Midfielder : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a midfielder, I have {Skills.Count} skills");
	
}

public class Forward : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a forward player, I have {Skills.Count} skills");
	
}

public class GoalKeeper : Player {

	public override string GetDescription() => $("I am a goalkeeper, I have {Skills.Count} skills");
	
}

#endregion
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    /// <summary>
    /// Entry point into console application.
    /// </summary>
    static void Main()
    {
	  // Create a goalkeeper
      GoalKeeperFactory gkFactory = new GoalKeeperFactory();
	  Player goalkeeper = gkFactory.CreatePlayer();
	  List<Coach> gkCoachs = gkFactory.CreateCoachs();
	  Console.WriteLine($"{goalkeeper.GetDescription()} and I need {gkCoachs.Count} coachs :");
	  foreach(Coach c in gkCoachs) {
		Console.WriteLine("   - " + c.GetType().Name);
	  }
	  
	  
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>Still to delegate and encapsulate the creation logic complexity, but when you have interrelated dependencies.</p>
				<!--
				<h3></h3>
				<p>Wikipedia says :</p>
				<blockquote></blockquote>
				<p>In plain words, </p>
				<p>Real world example :<p>
				<p></p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
</code></pre>
				<p>When to use it ?<p>
				<p></p>
				-->
				<div id="crdny">February 26, 2017</div>
				<div id="tags_wrapper">
					<ul>
						<li>Design Patterns</li>
						<li>Design Pattern</li>
						<li>Simple Factory</li>
						<li>Factory Method</li>
						<li>Abstract Factory</li>
					</ul>
				</div>
				<div id="refs_wrapper">
					<ul>
						<!--<li><a href="" title="" target="_Blank"></a></li>
						<li><a href="" title="" target="_Blank"></a></li>-->
					</ul>
				</div>
            </div>
			<footer>
			</footer>
		</div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js" type="text/javascript"></script>
		<script src="/wwwroot/js/Infra.js" type="text/javascript"></script>
		<link type="text/css" rel="stylesheet" href="/wwwroot/lib/highlight/styles/vs.css" />
		<script type="text/javascript" src="/wwwroot/lib/highlight/highlight.pack.js"></script>
		<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85948839-1', 'auto');
  ga('send', 'pageview');

</script>
	</body>
</html>