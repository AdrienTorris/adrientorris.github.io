<!DOCTYPE html>
<html lang="en-US" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
		<title>Design Patterns explained</title>
		<link rel="shortcut icon" href="/wwwroot/favicon.ico" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name="language" content="en" />
		<meta name="keywords" content="Design Patterns,design pattern,Creational Design Patterns,structural design patterns,behavioral design patterns" />
		<meta name="description" content="Design Patterns explained" />
		<meta name="author" content="Adrien Torris" />
		<meta name="robots" content="index,follow" />
		<meta name="generator" content="No404! 0.1" />
		<link rel="alternate" href="https://adrientorris.github.io/elegant-code/design-patterns-explained.html" hreflang="en-en" />
		<link href="/wwwroot/css/style.css" rel="stylesheet" />
	</head>
	<body>
		<div id="main_ctn" class="post_ctn">
			<header>
				<div id="header-content">
					<h2>Blog</h2>
				</div>
			</header>
			<div id="arianne_wrapper">
				<ul>
					<li><a href="https://adrientorris.github.io/index.html" title="">Home</a></li>
					<li>elegant code</li>
					<li class="active"><a href="https://adrientorris.github.io/elegant-code/design-patterns-explained.html" title="Design Patterns explained">Design Patterns explained</a></li>
				</ul>
			</div>
			<div id="post_ctn">
            </div>
			<div id="post_ctn">
				<h1>Design Patterns explained</h1>
				<p></p>
				<h2>Types of Design Patterns</h2>
				<ul>
					<li>
						<a href="#creational_design_pattern_title" title="">Creational</a>
						<ul>
							<li><a href="#simple_factory_ttl" title="">Simple Factory</a></li>
							<li><a href="#factory_method_ttl" title="">Factory Method</a></li>
							<li><a href="#abstract_factory_ttl" title="">Abstract Factory</a></li>
							<li><a href="#builder_ttl" title="">Builder</a></li>
							<li><a href="#prototype_ttl" title="">Prototype</a></li>
							<li><a href="#singleton_ttl" title="">Singleton</a></li>
						</ul>
					</li>
					<li>
						<a href="#structural_design_pattern_title" title="">Structural</a>
						<ul>
							<li><a href="#adapter_ttl" title="">Adapter</a></li>
							<li><a href="#bridge_ttl" title="">Bridge</a></li>
							<li><a href="#composite_ttl" title="">Composite</a></li>
							<li><a href="#decorator_ttl" title="">Decorator</a></li>
							<li><a href="#facade_ttl" title="">Facade</a></li>
							<li><a href="#flyweight_ttl" title="">Flyweight</a></li>
							<li><a href="#proxy_ttl" title="">Proxy</a></li>
						</ul>
					</li>
					<li>
						<a href="behavioral_design_pattern_title" title="">Behavioral</a>
						<ul>
							<li><a href="#chain_of_responsability_ttl" title="">Chain of Responsibility</a></li>
							<li><a href="#" title="">Command</a></li>
							<li><a href="#" title="">Iterator</a></li>
							<li><a href="#" title="">Mediator</a></li>
							<li><a href="#" title="">Memento</a></li>
							<li><a href="#" title="">Observer</a></li>
							<li><a href="#" title="">Visitor</a></li>
							<li><a href="#" title="">Strategy</a></li>
							<li><a href="#" title="">State</a></li>
							<li><a href="#" title="">Template Method</a></li>
						</ul>
					</li>
				</ul>
				<h2 id="creational_design_pattern_title">Creational Design Patterns</h2>
				<p>A creational design pattern is focused towards how to instantiate an object or group of related objects.</p>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, creational design patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</blockquote>
				<h3 id="simple_factory_ttl">Simple Factory</h3>
				<p>Wikipedia says :</p>
				<blockquote>In object-oriented programming (OOP), a factory is an object for creating other objects – formally a factory is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be "new".</blockquote>
				<p>In plain words, a factory in its simplest form (it's also exists abstract factory pattern and method factory pattern) is a class which has a method that returns differents type of object.</p>
				<p>Real world example :<p>
				<p>Consider you are building vehicles (like cars, motorbikes, trucks and others), it would be painfull if each time you need to put the wheels on the vehicle you need to think about it and start making the new wheels from the start. Instead you get them made from a factory.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;Contract each wheel for a vehicle have to respect
&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
public interface IVehicleWheel{
	
	int GetWidth();
	int GetDiameter();
	
}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;A wheel for a car
&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
public class CarWheel : IVehicleWheel {

	&#47;&#47;&#47;&#32;&#60;summary&#62;
	&#47;&#47;&#47;&#32;Width of the wheel in inches
	&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
	public int Width { get; }
	
	&#47;&#47;&#47;&#32;&#60;summary&#62;
	&#47;&#47;&#47;&#32;Diameter of the wheel in inches
	&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
	public int Diameter { get; }
	
	&#47;&#47;&#47;&#32;&#60;summary&#62;
	&#47;&#47;&#47;&#32;New instance of a car wheel
	&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
	public CarWheel(int width, int diameter) {
	
		Width = width;
		Diameter = diameter;
		
	}
	
	public int GetWidth() &#61;&#62; Width;
	
	public int GetDiameter() &#61;&#62; Diameter;
	
}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;Class to instanciate all the wheels you need
&#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
public static class WheelFactory {

	public static IVehicleWheel MakeCarWheel(int width, int diameter) &#61;&#62; new CarWheel(width, diameter);

}
</code></pre>
				<p>And then it can be used as :</p>
<pre><code class="csharp">
IVehicleWheel wheel = WheelFactory.MakeCarWheel(15, 30);
</code></pre>
				<p>When to use it ?<p>
				<p>When creating an object isn't just a few assignements but involves some business logic, it makes sense to put the logic in a dedicated factory instead of repeating the code everywhere.</p>
				<h3 id="factory_method_ttl">Factory Method</h3>
				<p>Wikipedia says :</p>
				<blockquote>In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.</blockquote>
				<p>In plain words, a Factory Method provides a way to delegate the instanciation logic to subclasses. It defines an interface for creating an object but let's his subclasses implement this interface and decide which class to instanciate.</p>
				<p>Real world example :<p>
				<p>Consider a football player, it's impossible for one person to be very good in each game position, so you have to delegate some parts of the game to others players.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
#region Skills

public abstract class Skill
{

}

public class Acrobat : Skill {

}

public class Dribbler : Skill {

}

public class DistanceShooter : Skill {

}

public class Speedster : Skill {

}

public class Tackling : Skill {

}

public class Tactician : Skill {

}

public class ClinicalFinisher : Skill {

}

public class Strenght : Skill {

}

public class Playmaker : Skill {

}

public class Engine : Skill {

}

public class Reflex : Skill {

}

public class Tall : Skill {

}

public class Springiness : Skill {

}

public class ExtremeConcentration : Skill {

}

#endregion

#region Players

public abstract class Player()
{
	public List&#60;Skill&#62; Skills { get; protected set;}
	
	// Factory Method
    public abstract void CreateSkills();

	public Player() {
		
		CreateSkills();
		
	}
}

public class Defender : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new Strenght());
		Skills.Add(new Tackling());
		Skills.Add(new Tall());
	
	}
	
}

public class Midfielder : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new Engine());
		Skills.Add(new Playmaker());
		Skills.Add(new Tactician());
	
	}
	
}

public class Forward : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new ClinicalFinisher());
		Skills.Add(new Speedster());
		Skills.Add(new Dribbler());
		Skills.Add(new Acrobat());
	
	}
	
}

public class GoalKeeper : Player {

	// Factory Method implementation
	public override void CreateSkills(){
	
		Skills = new ListList&#60;Skill&#62;();
		
		Skills.Add(new Reflex());
		Skills.Add(new Tall());
		Skills.Add(new Springiness());
		Skills.Add(new ExtremeConcentration());
	
	}
	
}

#endregion
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  // Create a list of players
      List&#60;Player&#62; players = new List&#60;Player&#62;();
	  players.Add(new GoalKeeper());
	  players.Add(new Defender());
	  players.Add(new Midfielder());
	  players.Add(new Forward());
 
      // Display player skills
      foreach (Player player in players)
      {
        Console.WriteLine("\n" + player.GetType().Name + "--");
        foreach (Skill skill in player.Skills)
        {
          Console.WriteLine(" " + skill.GetType().Name);
        }
      }
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>When there is some generic processing in a class but you doesn't know what exact subclass it might need, so you let the child class decide.</p>
				<h3 id="abstract_factory_ttl">Abstract Factory</h3>
				<p>Wikipedia says :</p>
				<blockquote>The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes</blockquote>
				<p>In plain words, an abstract factory is a factory of factories. It's a class that groups the individual but related/dependent factories together without specifying their concrete classes. </p>
				<p>Real world example :<p>
				<p>To stay in the football world, we still have our different kind of players with their own skills, let consider now the coaches. The differents players doesn't need the same coach to progress. A goalkeeper needs a specific coach to his position, as a forward player needs some coaches to work on his shoot, his dribble and his velocity. So as we have different kind of players, we have different kinf of instructors with their specialities and as you can see, there is a dependency between the players and the coaches.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
#region Coachs

public abstract class Coach {

}

public class GoalKeeperCoach : Coach {
}

public class DribbleCoach : Coach {
}

public class ShootCoach : Coach {
}

public class TacklingCoach : Coach {
}

public class TacticianCoach : Coach {
}

public class PassCoach : Coach {
}

public class MuscleDevelopmentCoach : Coach {
}

#endregion

#region Skills

public abstract class Skill
{

}

public class Acrobat : Skill {

}

public class Dribbler : Skill {

}

public class Shooter : Skill {

}

public class DistanceShooter : Skill {

}

public class Speedster : Skill {

}

public class Tackling : Skill {

}

public class Tactician : Skill {

}

public class ClinicalFinisher : Skill {

}

public class Strenght : Skill {

}

public class Playmaker : Skill {

}

public class Engine : Skill {

}

public class Reflex : Skill {

}

public class Tall : Skill {

}

public class Springiness : Skill {

}

public class ExtremeConcentration : Skill {

}

public class ClinicalPasser : Skill {

}

#endregion

#region Factories

public abstract class PlayerFactory {

	public abstract Player CreatePlayer();
	
	public abstract List&#60;Coach&#62; CreateCoachs();
	
}

public class GoalKeeperFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills = new List&#60;Skill&#62;();
		player.Skills.Add(new Tall());
		player.Skills.Add(new Reflex());
		player.Skills.Add(new ExtremeConcentration());
		player.Skills.Add(new Springiness());
		return player;
	
	}
	
	public override List&#60;Coach&#62; CreateCoachs() {
		List&#60;Coach&#62; ret = new List&#60;Coach&#62;();
		ret.Add(new GoalKeeperCoach());
		return ret;
	}

}

public class DefenderFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills.Add(new Strenght());
		player.Skills.Add(new Tall());
		player.Skills.Add(new Tackling());
		return player;
	
	}
	
	public override List&#60;Coach&#62; CreateCoachs() {
		List&#60;Coach&#62; ret = new List&#60;Coach&#62;();
		ret.Add(new TacklingCoach());
		ret.Add(new MuscleDevelopmentCoach());
		return ret;
	}

}

public class MidfielderFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills.Add(new Dribble());
		player.Skills.Add(new Tactician());
		player.Skills.Add(new Tackling());
		player.Skills.Add(new ClinicalPasser());
		player.Skills.Add(new Playmaker());
		return player;
	
	}
	
	public override List&#60;Coach&#62; CreateCoachs() {
		List&#60;Coach&#62; ret = new List&#60;Coach&#62;();
		ret.Add(new TacklingCoach());
		ret.Add(new DribbleCoach());
		ret.Add(new PassCoach());
		ret.Add(new TacticianCoach());
		return ret;
	}

}

public class ForwardFactory : PlayerFactory {

	public override Player CreatePlayer() {
	
		GoalKeeper player = new GoalKeeper();
		player.Skills.Add(new Speedster());
		player.Skills.Add(new Acrobat());
		player.Skills.Add(new Shooter());
		player.Skills.Add(new ClinicalFinisher());
		player.Skills.Add(new Dribble());
		return player;
	
	}
	
	public override List&#60;Coach&#62; CreateCoachs() {
		List&#60;Coach&#62; ret = new List&#60;Coach&#62;();
		ret.Add(new ShootCoach());
		ret.Add(new DribbleCoach());
		return ret;
	}

}

#endregion

#region Players

public abstract class Player()
{
	public List&#60;Skill&#62; Skills { get; set;}
	
	public abstract string GetDescription();
}

public class Defender : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a defender, I have {Skills.Count} skills");
	
}

public class Midfielder : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a midfielder, I have {Skills.Count} skills");
	
}

public class Forward : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a forward player, I have {Skills.Count} skills");
	
}

public class GoalKeeper : Player {

	public override string GetDescription() &#61;&#62; &#36;("I am a goalkeeper, I have {Skills.Count} skills");
	
}

#endregion
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  // Create a goalkeeper
      GoalKeeperFactory gkFactory = new GoalKeeperFactory();
	  Player goalkeeper = gkFactory.CreatePlayer();
	  List&#60;Coach&#62; gkCoachs = gkFactory.CreateCoachs();
	  Console.WriteLine($"{goalkeeper.GetDescription()} and I need {gkCoachs.Count} coachs :");
	  foreach(Coach c in gkCoachs) {
		Console.WriteLine("   - " + c.GetType().Name);
	  }
	  
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>Still to delegate and encapsulate the creation logic complexity, but when you have interrelated dependencies.</p>
				<h3 id="builder_ttl">Builder</h3>
				<p>Wikipedia says :</p>
				<blockquote>The builder pattern is an object creation software design pattern with the intentions of finding a solution to the telescoping constructor anti-pattern.</blockquote>
				<p>In plain words, a builder avoid the constructor pollution with options. It allows you to create the same object with different configurations.</p>
				<p>Real world example :<p>
				<p>Imagine you are at a Lamborghini's dealer and you order a car, let's say the Aventador. If the seller brought a car to you without any questions, this is an example of a simple factory. But there are cases when the creation logic might involve more steps, for example in this case, you probably want a customized car. Which color do you want ? Which options ? Wood or aluminium finish for the dashboard ? Which motor power ? In such cases builder pattern comes to the rescue.</p>
				<p>Programmatic example :<p>
				<p>Using a telescoping constructor anti-pattern :</p>
<pre><code class="csharp">
public class Car {

	public string Manufacturer {get;set;}
	public string Model {get;set;}
	public int Doors { get; set; } = 5;
	public string Color { get; set; } = "black";
	public string DashboardFinish { get; set; } = "wood";
	
	public Car(string manufacturer, string model, int? doors, string color, string dashboardFinish){
	
		Manufacturer = manufacturer;
		Model = model;
	
		if(doors.HasValue){
			Doors = doors;
		}
		
		if(!string.IsNullOrWhiteSpace(color)){
			Color = color:
		}
		
		if(!string.IsNullOrWhiteSpace(dashboardFinish)){
			DashboardFinish = dashboardFinish:
		}
	}

}
</code></pre>
				<p>Using a builder design pattern :</p>
<pre><code class="csharp">
public class Car {

	public string Manufacturer {get;set;}
	public string Model {get;set;}
	public int Doors { get; set; } = 5;
	public string Color { get; set; } = "black";
	public string DashboardFinish { get; set; } = "wood";
	
	public Car(string manufacturer, string model){
	
		Manufacturer = manufacturer;
		Model = model;
	}

}

public class CarBuilder {

	private Car Car { get; set; }
	
	public CarBuilder(string manufacturer, string model){
		Car = new Car(manufacturer, model);
	}
	
	public void SetNbDoors(int count) &#61;&#62; car.Doors &#61; count;
	
	public void SetColor(string color) &#61;&#62; car.Color &#61; color;
	
	public void SetDashboardFinish(string finish) &#61;&#62; car.DashboardFinish &#61; finish;
	
	public Car Build() &#61;&#62; return Car;

}
</code></pre>
				<p>And you can use it like :</p>
<pre><code class="csharp">
CarBuilder carBuilder = new CarBuilder("Lamborghini", "Aventador");
carBuilder.SetNbDoors(3);
carBuilder.SetColor("orange");
Car myDreamCar = carBuilder.Build();
</code></pre>
				<p>When to use it ?<p>
				<p>When the creation logic of an object includes several steps. This is the difference between a factory, in which the creation logic is a one step process, and a builder who is used when the same construction process can create different representations of the same object.</p>
				<h3 id="prototype_ttl">Prototype</h3>
				<p>Wikipedia says :</p>
				<blockquote>The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.</blockquote>
				<p>In plain words, a prototype creates an object based on an existing object through cloning.</p>
				<p>Real world example :<p>
				<p>Remember dolly? The sheep that was cloned! Lets not get into the details but the key point here is that it is all about cloning</p>
				<!--<p>Programmatic example :<p>
<pre><code class="csharp">
</code></pre>-->
				<p>When to use it ?<p>
				<p>When you need the exact same object as an existing object.</p>
				<h3 id="singleton_ttl">Singleton</h3>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.</blockquote>
				<p>In plain words, a singleton ensures that only one instance of an object is ever created.</p>
				<p>Real world example :<p>
				<p>Consider there is only one Universe, all the solar systems and planets are sharing the same Universe, so the Universe is a singleton.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
public class Universe 
{
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;The speed of light in m/s
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
	public const int SpeedOfLight = 300000000;
	
	private static Universe instance;
	
	private Universe() {}
	
	public static Universe Instance
	{
		get
		{
			if(instance == null){
				instance = new Universe();
			}
			
			return instance;
		}
	}

}
</code></pre>
				<p>When to use it ?<p>
				<p>When you need that an object have to have only one instance at a time in your application (file logger, ...)</p>
				<h2 id="structural_design_pattern_title">Structural Design Patterns</h2>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities.</blockquote>
				<p>In plain words :</p>
				<blockquote>The concern of the structural patterns is how the entities can use each other.</blockquote>
				<h3 id="adapter_ttl">Adapter</h3>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.</blockquote>
				<p>In plain words, an adapter let's you wrap an otherwise incompatible object in an adapter to make it compatible with another class.</p>
				<p>Real world example :<p>
				<p>A good example is when you need to plug something in a foreign country, let's say France and Scotland. This both countries have differents plug interface, so you absolutely not plug your french charger in a plug in Scotland. So you go to a store and buy an <b>adapter</b> : a charger who have a side to communicate with a French charger, and another who can communicate with a scottish one, without modify any of this both objects.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
public class Player
{
	public string Name { get; }
	public DateTime Birthday { get; }
	public int Level { get; }
	
	// Pace
	public int SprintSpeed { get; }
	public int Acceleration { get; }
	
	// Shooting
	public int Finishing { get; }
	public int LongShots { get; }
	public int ShotPower { get; }
	public int AttackPositioning { get; }
	public int Penalties { get; }
	public int Volleys { get; }
	
	// Passing
	public int ShortPassing { get; }
	public int LongPassing { get; }
	public int Vision { get; }
	public int Crossing { get; }
	public int FKAccuracy { get; }
	public int Curve { get; }
	
	// Dribbling
	public int Dribbling { get; }
	public int BallControl { get; }
	public int Agility { get; }
	public int Balance { get; }
	public int Reactions { get; }
	
	// Defending
	public int Marking { get; }
	public int StandTackle { get; }
	public int Interceptions { get; }
	public int HeadingAccuracy { get; }
	public int SlideTackle { get; }
	
	// Physical
	public int Strength { get; }
	public int Aggression { get; }
	public int Stamina { get; }
	public int Jumping { get; }
	
	// Mental
	public int Concentration { get; }
	public int Leadership { get; }
	public int SelfControl { get; }
	public int Presence { get; }
	
	//
	public virtual string GetPresentationMessage() &#61;&#62; $"My name is {Name}, I am born in {Birthday.Year} and I am a {Level &#62;&#61; 80 ? "very good" : Level &#62;&#61; 65 ? "good" : string.Empty} football player.";
}

public abstract class Skill
{}

public class Shooter : Skill
{}

public class Dribbler : Skill
{}

public class Leader : Skill
{}

public class Wall : Skill
{}

public class Athlete : Skill
{}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;The 'Adapter' class
&#47;&#47;&#47;&#32;&#60;/summary&#62;
public class SkilledPlayer : Player
{
	private SkillBank _skillBank &#61; new SkillBank();
	
	public SkilledPlayer()
		: base()
	{
	}
	
	public override string GetPresentationMessage()
	{
		string ret &#61; base.GetPresentationMessage();
		
		List&#60;Skill&#62; skills &#61; _skillBank.GetSkills(this);
		
		if(skills &#61;&#61; null || skills.Count &#61;&#61; 0)
			return ret;
			
		foreach(Skill skill in skills){
			ret +&#61; $"I am a {skill.GetType().Name}. ";
		}
		
		return ret;
	}
}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;The 'Adaptee' class
&#47;&#47;&#47;&#32;&#60;summary&#62;
public class SkillBank
{
	private const int _skillMinLevel &#61; 80;
	
	private const int _skilledPlayerMinGlobalLevel &#61; 55;
	
	public List&#60;Skill&#62; GetSkills(Player player)
	{
		List&#60;Skill&#62; ret &#61; new List&#60;Skill&#62;();
		
		if(player.Level &#60; _skilledPlayerMinGlobalLevel){
			return ret;
		}

		if(HasShooterSkill(player))
			ret.Add(new Shooter());

		if(HasDefenderSkill(player))
			ret.Add(new Wall());
			
		return ret;
	}
	
	private bool HasShooterSkill(Player player){
		if(player.Finishing &#62;&#61; _skillMinLevel && player.ShotPower &#62;&#61; _skillMinLevel && player.AttackPositioning &#62;&#61; _skillMinLevel)
			return true;
			
		return false;
	}
	
	private bool HasDefenderSkill(Player player){
		int i = 0;
		
		if(player.Marking &#62;&#61; _skillMinLevel)
			i &#61; i++;
		
		if(player.StandTackle &#62;&#61; _skillMinLevel)
			i &#61; i++;
		
		if(player.SlideTackle &#62;&#61; _skillMinLevel)
			i &#61; i++;
		
		if(player.HeadingAccuracy &#62;&#61; _skillMinLevel)
			i &#61; i++;
		
		if(player.Interceptions &#62;&#61; _skillMinLevel)
			i &#61; i++;
		
		if(player.Strength &#62;&#61; _skillMinLevel)
			i &#61; i++;
		
		if(player.Aggression &#62;&#61; _skillMinLevel)
			i &#61; i++;
			
		if(i &#62;&#61; 5)
			return true;
			
		return false;
	}
}
</code></pre>
				<p>When to use it ?<p>
				<p>When you need that some classes have to collaborate but have incompatible interfaces.</p>
				<h3 id="bridge_ttl">Bridge</h3>
				<p>Wikipedia says :</p>
				<blockquote>The bridge pattern is a design pattern used in software engineering that is meant to "decouple an abstraction from its implementation so that the two can vary independently"</blockquote>
				<p>In plain words, the bridge pattern is about preferring composition over inheritance.</p>
				<p>Real world example :<p>
				<p>In the football management game you develop, you can pick any Premier League team to manage it. Each team has his own logo, his graphic theme and other graphical elements. Your game has 25 differents user interfaces so what are you doing ? You develop all the interface in all the themes available, and display the interfaces corresponding to the team the user choose ? Or you develop the interfaces and the themes independently, and load the good theme when you display a user interface ? If you choose the second option, it's a Bridge pattern. Otherwise, if you choose the first option, it's a Mess anti-pattern and just stay away from me...</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
/// <summary>
/// The 'Bridge/Implementor' interface
/// </summary>
public interface IMessageSender
{
	void Send(string subject, string body);
}

/// <summary>
/// The 'ConcreteImplementor' class
/// </summary>
public sealed class EmailSender : IMessageSender
{
	public void Send(string subject, string body)
	{
		// Business logic to send a mail
		Console.WriteLine($"Email : {subject} - {body}");
	}
}

/// <summary>
/// The 'ConcreteImplementor' class
/// </summary>
public sealed class SMSSender : IMessageSender
{
	public void Send(string subject, string body)
	{
		// Business logic to send a SMS
		Console.WriteLine($"SMS : {subject} - {body}");
	}
}

/// <summary>
/// The 'Abstraction' class
/// </summary>
public abstract class Message
{
	public string Subject { get; set; }
	public string Body { get; set; }
	
	public IMessageSender Sender { get; set; }
	public abstract void Send();
}

/// <summary>
/// The 'RefinedAbstraction' class
/// </summary>
public sealed class PlayerMessage : Message
{
	public string Name { get; set; }
	public int Level { get; set; }
	
	public PlayerMessage(string name, int level)
	:base()
	{
		Name = name;
		Level = level;
	}
	
	public override void Send()
	{
		string fullBody = $"The player {Name} (level {Level}) sends the message: {Body}";
		Sender.Send(Subject, fullBody);
	}
}

/// <summary>
/// The 'RefinedAbstraction' class
/// </summary>
public sealed class CoachMessage : Message
{
	public override void Send()
	{
		MessageSender.Send(Subject, Body);
	}
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  IMessageSender emailSender = new EmailSender();
	  IMessageSender smsSender = new SMSSender();
	  
	  // Send a player message
	  
	  Message msg1 = new PlayerMessage("Zidane", 95);
	  msg1.Subject = "Test message";
	  msg1.Body = "This is the body of the test message.";
	  
	  // Send - email
	  msg1.Sender = emailSender;
	  msg1.Send();
	  
	  // Send - SMS
	  msg1.Sender = smsSender;
	  msg1.Send();
	  
	  // Send a coach message
	  
	  Message msg2 = new CoachMessage();
	  msg2.Subject = "Test message";
	  msg2.Body = "This is the body of the test message.";
	  
	  // Send - email
	  msg2.Sender = emailSender;
	  msg2.Send();
	  
	  // Send - SMS
	  msg2.Sender = smsSender;
	  msg2.Send();
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<!--<p>When to use it ?<p>
				<p></p>-->
				<h3 id="composite_ttl">Composite</h3>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes that a group of objects is to be treated in the same way as a single instance of an object. The intent of a composite is to "compose" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.</blockquote>
				<p>In plain words, the composite pattern composes objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p>
				<p>Real world example : <p>
				<p>Think about the Universe. It is composed by planets, stars, galaxies, and so much things. All this things are space elements with common attributes, like a Name, a density, a chimical composition, ... and it exists a hierarchy between them : a universe owns some galaxies, who owns some systems who owns some planets.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
public abstract class SpaceElement
{
	public string Name { get; set; }
	
	public SpaceElement(string name){
		Name = name;
	}
	
	public abstract void Display();
}

public class Universe : SpaceElement
{
	public IEnumerable<SpaceElement> Galaxies { get; set; }
	
	public void AddGalaxy(Galaxy g){
		Galaxies.Add(g);
	}
	
	public override void Display()
	{
		Console.WriteLine($"{Name} - I am the Universe");
		Console.WriteLine($"I have {Galaxies.Count()} galaxies :");
		foreach(SpaceElement g in Galaxies){
			g.Display();
		}
	}
}

public class Galaxy : SpaceElement
{
	public IEnumerable<SpaceElement> SolarSystems { get; set; }
	
	public void AddSystem(SolarSystem s){
		SolarSystems.Add(s);
	}
	
	public override void Display()
	{
		Console.WriteLine($"{Name} - Galaxy");
		Console.WriteLine($"I have {SolarSystems.Count()} solar systems :");
		foreach(SpaceElement s in SolarSystems){
			s.Display();
		}
	}
}

public class SolarSystem : SpaceElement
{
	public IEnumerable<SpaceElement> Stars { get; set; }
	public IEnumerable<SpaceElement> Planets { get; set; }
	
	public void AddStar(Star s){
		Stars.Add(s);
	}
	
	public void AddPlanet(Planet p){
		Planets.Add(p);
	}
	
	public override void Display()
	{
		Console.WriteLine($"{Name} - SolarSystem");
		Console.WriteLine($"I have {Stars.Count()} stars :");
		foreach(SpaceElement s in Stars){
			s.Display();
		}
		Console.WriteLine($"I have {Planets.Count()} planets :");
		foreach(SpaceElement p in Planets){
			p.Display();
		}
	}
}

public class Star : SpaceElement
{
	public override void Display() => Console.WriteLine($"{Name} (star)");
}

public class Planet : SpaceElement
{
	public override void Display() => Console.WriteLine($"{Name} (planet)");
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  SpaceElement earth = new Planet("Earth");
	  
	  SpaceElement sun = new Star("Sun");
	  
	  SolarSystem solarSystem = new SolarSystem("Solar system");
	  solarSystem.AddStar(sun);
	  solarSystem.AddPlanet(earth);
	  
	  SpaceElement milkyWay = new Galaxy("Milky Way");
	  milkyWay.AddSystem(solarSystem);
	  
	  SpaceElement universe = new Universe("Our Universe");
	  universe.AddGalaxy(milkyWay);
	  
	  universe.Display();
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<!--<p>When to use it ?<p>
				<p></p>-->
				<h3 id="decorator_ttl">Decorator</h3>
				<p>Wikipedia says :</p>
				<blockquote>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.</blockquote>
				<p>In plain words, the decorator pattern lets you dynamically attach additional responsabilities to an object. A decorator is an alternative to inheritance.</p>
				<!--<p>Real world example :<p>
				<p></p>-->
				<p>Programmatic example :<p>
<pre><code class="csharp">
public class RentalAgency
{
	public string Name { get; set; }
	public IEnumerable&#60;Vehicle&#62; Vehicles { get; set; }
}

public abstract class Vehicle
{
	public string Model { get; set; }
	public string Manufacturer { get; set; }
	public int NumCopies { get; set; }
	
	public Vehicle(string manufacturer, string model, int copies)
	{
		Manufacturer = manufacturer;
		Model = model;
		NumCopies = copies;
	}
	
	public abstract void Display();
}

public class Car : Vehicle
{
	public Car(string manufacturer, string model, int copies)
	{
		Manufacturer = manufacturer;
		Model = model;
		NumCopies = copies;
	}
	
	public override void Display() =&#62; Console.WriteLine($"(car) {Manufacturer} {Model} - Copies: {NumCopies}");
}

public class Truck : Vehicle
{
	public int Capacity { get; set; }

	public Truck(string manufacturer, string model, int copies, int capacity)
	{
		Manufacturer = manufacturer;
		Model = model;
		NumCopies = copies;
		Capacity = capacity;
	}
	
	public override void Display() =&#62; Console.WriteLine($"(truck) {Manufacturer} {Model} - Capacity: {Capacity} - Copies: {NumCopies}");
}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;The 'Decorator' abstract class
&#47;&#47;&#47;&#32;&#60;/summary&#62;
public abstract class Decorator : Vehicle
{
	protected Vehicle vehicle;

	public Decorator(Vehicle v)
	{
    	vehicle = v;
	}

	public override void Display() =&#62; vehicle.Display();
}

&#47;&#47;&#47;&#32;&#60;summary&#62;
&#47;&#47;&#47;&#32;The 'ConcreteDecorator' class
&#47;&#47;&#47;&#32;&#60;/summary&#62;
public class Borrowable : Decorator
{
	protected List&#60;string&#62; borrowers = new List&#60;string&#62;();
	
	public Borrowable(Vehicle vehicle)
	  : base(vehicle)
	{ }
	
	public void Borrow(string name)
	{
		borrowers.Add(name);
		vehicle.NumCopies--;
	}
	
	public void Return(string name)
	{
		borrowers.Remove(name);
		vehicle.NumCopies++;
	}
	
	public override void Display()
	{
		base.Display();
		
		if(borrowers == null || borrowers.Count == 0)
			return;
			
		Console.WriteLine(borrowers.Count + "borrower" + (borrowers.Count &#62; 1 ? "s" : string.Empty));
		
		foreach(string borrower in borrowers)
			Console.WriteLine(" - " + borrower);
	}
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  Car aventador = new Car("Lamborghini", "Aventador", 8);
	  aventador.Display();
	  
	  Car carerra = new Car("Porshe", "Carrera 4", 6);
	  carerra.Display();
	  
	  // Make the Lamborghini Aventador borrowable
	  Borrowable borrowableAventador = new Borrowable(aventador);
	  borrowableAventador.Borrow("Customer #1");
	  borrowableAventador.Borrow("Customer #2");
	  
	  borrowableAventador.Display();
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>When you want to add some behaviors to an object without modify or extend it.</p>
				<h3 id="facade_ttl">Facade</h3>
				<p>Wikipedia says :</p>
				<blockquote>A facade is an object that provides a simplified interface to a larger body of code, such as a class library.</blockquote>
				<p>In plain words, facade pattern provides a simplified interface to a complex subsystem.</p>
				<p>Real world example :<p>
				<p>Facade are everywhere ! When you turn on your car you just turn a key, such a simple movement. But there are dozens of things who appends in the car to turn on the motor. The key's movement hides all the subsystem complexity, it's a facade.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
public class Car
{
	public string Model { get; set; }
	public string Manufacturer { get; set; }
	
	public Car(string manufacturer, string model)
	{
		Manufacturer = manufacturer;
		Model = model;
	}
	
	public void Start()
	{
		if(!HasBatteryPower())
		{
			Console.WriteLine("The car can't start");
			Return;
		}
		
		if(!HasFuel())
		{
			Console.WriteLine("The car can't start");
			Return;
		}
		
		if(!CallInjector())
		{
			Console.WriteLine("The car can't start");
			Return;
		}
		
		if(!TurnOnSparkPlug())
		{
			Console.WriteLine("The car can't start");
			Return;
		}
		
		if(!StartMotor())
		{
			Console.WriteLine("The car can't start");
			Return;
		}
		
		Console.WriteLine("The car just started !");
	}
	
	private bool HasBatteryPower()
	{
	}
	
	private bool HasFuel()
	{
	}
	
	private bool CallInjector()
	{
	}
	
	private bool TurnOnSparkPlug()
	{
	}
	
	private bool StartMotor()
	{
	}
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  Car aventador = new Car("Lamborghini", "Aventador", 8);
	  aventador.Start();
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>When for some reason you prefer keep the complexity of a system secret.</p>
				<h3 id="flyweight_ttl">Flyweight</h3>
				<p>Wikipedia says :</p>
				<blockquote>A flyweight is an object that minimizes memory use by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory.</blockquote>
				<p>In plain words, use sharing to minimize memory usage and support a large numbers of fine-grained objects efficiently.</p>
				<p>Real world example :<p>
				<p>The canonical example of the flyweight pattern is the text editor. Image an english text editor without numbers or any special character, you have just 26 characters, but you can use them a multiple times. If you open a book text file, you will have tens of thousands characters, but same 26 ones. So, what do you do ? Are you create a new complete object for each of thems, knowing that you will have thousands of times the same characters ? Or you create one instance for each of the 26 characters, and you use it when you need ? The second option is called a flyweight pattern, about sharing resources.</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
public abstract class Letter
{
	protected char symbol;
	protected int htmlNumber;
	
	public abstract void Display(int idx);
}

public sealed class LetterA : Letter
{
	public LetterA()
	{
		symbol = 'A';
		htmlNumber = 97;
	}
	
	public override void Display(int idx) =&#62; Console.WriteLine($"Document contains the character '{symbol}' at the position {idx}");
}

public sealed class LetterB : Letter
{
	public LetterB()
	{
		symbol = 'B';
		htmlNumber = 98;
	}
	
	public override void Display(int idx) =&#62; Console.WriteLine($"Document contains the character '{symbol}' at the position {idx}");
}

// C, D, E, ...

public sealed class LetterZ : Letter
{
	public LetterZ()
	{
		symbol = 'Z';
		htmlNumber = 122;
	}
	
	public override void Display(int idx) =&#62; Console.WriteLine($"Document contains the character '{symbol}' at the position {idx}");
}

public class LetterFactory
{
	private Dictionary&#60;char, Letter&#62; _instances = new Dictionary&#60;char, Letter&#62;();
	
	public Letter GetLetter(char key)
	{
		Letter ret = null;
		
		if(_instances.ContainsKey(key))
			ret = _instances[key];
		else
		{
			switch(key)
			{
				case 'A':
					ret = new LetterA();
					break;
				case 'B':
					ret = new LetterB();
					break;
				// C, D, E, ...
				case 'Z':
					ret = new LetterZ();
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}
		}
		
		return ret;
	}
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  string documentString = "THISISMYTEXT";
	  char[] docChars = documentString.ToCharArray();
	  
	  LetterFactory factory = new LetterFactory();
	  
	  int docPosition = 0;
	  
	  foreach(char c in docChars)
	  {
		docPosition++;
		Letter l = factory.GetLetter(c);
		l.Display(docPosition);
	  }
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>When you have a few light objects but used a multiple times.</p>
				<h3 id="proxy_ttl">Proxy</h3>
				<p>Wikipedia says :</p>
				<blockquote>A proxy, in its most general form, is a class functioning as an interface to something else. A proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked.</blockquote>
				<p>In plain words, a proxy provides a surrogate or placeholder for another object to control access to it.</p>
				<p>Real world example :<p>
				<p>Have you ever try to watch a parent restricted channel on the TV when you were a child ? This is a perfect proxy example. All the TV channels have things in common but when you want to watch it, you pass by a proxy who check if you have the right to watch it, adding some access logic to the channel that the channel itself doesn't know.</p>
				<p>Placeholder programmatic example (add some behavior to access) :<p>
<pre><code class="csharp">
public interface ITVChannel
{
	void Watch();
	int GetNumber();
}

public class TVChannel : ITVChannel
{
	public int Number { get; set; }
	public string Name { get; set; }
	public bool IsParentRestrictedAccess { get; set; }
	
	public TVChannel(int number, string name, bool restricted){
		Number =  number;
		Name = name;
		IsParentRestrictedAccess = restricted;
	}
	
	public void Watch() =&#62; Console.WriteLine("You are watching " + Name);
	
	public int GetNumber() =&#62; Number;
}

public class TVChannelProxy
{
	private ITVChannel _channel;
	
	public TVChannelProxy(ITVChannel channel)
	{
		_channel = channel;
	}
	
	public void Watch(string password)
	{
		if(!_channel.IsParentRestrictedAccess)
		{
			_channel.Watch();
			return;
		}
		
		if(string.IsNullOrWhiteSpace(password))
		{
			Console.WriteLine("This channel has a restricted access. Please provide a password.");
			return;
		}
		
		if(password != "thepasswordstoredinsomeconstant")
		{
			Console.WriteLine("This channel has a restricted access. Please provide the good password.");
			return;
		}
		
		_channel.Watch();
	}
}

public class TVChannelsProxy
{
	private Dictionary&#60;int, TVChannelProxy&#62; _channels = new Dictionary&#60;int, TVChannelProxy&#62;();
	
	public TVChannelsProxy()
	{}
	
	public void AddChannel(ITVChannel channel)
	{
		if(_channels == null)
			_channels = new Dictionary&#60;int, ITVChannel&#62;();
			
		if(_channels.ContainsKey(channel.GetNumber()))
			return;
			
		_channels.Add(channel.GetNumber(), new TVChannelProxy(channel));
	}
	
	public void Watch(int channelNumber, string password)
	{
		if(_channels == null)
		{
			Console.WriteLine("This proxy doesn't handle this channel");
			return;
		}
		
		if(!_channels.ContainsKey(channelNumber))
		{
			Console.WriteLine("This proxy doesn't handle this channel");
			return;
		}
		
		TVChannelProxy channelProxy = _channels[channelNumber];
		channelProxy.Watch(password);
	}
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  ITVChannel arte = new TVChannel(7, "Arte", false);
	  ITVChannel france5 = new TVChannel(5, "France 5", false);
	  ITVChannel violentSportChannel = new TVChannel(32, "Violent Sports", true);
	  
	  TVChannelsProxy channelProxy = new TVChannelProxy();
	  channelProxy.AddChannel(arte);
	  channelProxy.AddChannel(france5);
	  channelProxy.AddChannel(violentSportChannel);
	  
	  channelProxy.Watch(arte.GetNumber(), null);
	  channelProxy.Watch(violentSportChannel.GetNumber(), null);
	  channelProxy.Watch(violentSportChannel.GetNumber(), "thepasswordstoredinsomeconstant");
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>Surrogate programmatic example (just control access) :<p>
<pre><code class="csharp">
public interface ISomeAPI
{
	string GetText(string id);
}

public class SomeAPI : ISomeAPI
{
	public string GetText(string id) =&#62; "this is some text, " + id;
}

public class APIProxy : ISomeAPI
{
	private SomeAPI _someAPI = new SomeAPI();
	
	public string GetText(string id) =&#62; _someAPI.GetText(id);
} 
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  APIProxy apiProxy = new APIProxy();
	  
	  console.WriteLine(apiProxy.GetText("a"));
	  console.WriteLine(apiProxy.GetText("B"));
	  console.WriteLine(apiProxy.GetText("c"));
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<p>When to use it ?<p>
				<p>When you want to control access to an object.</p>
				<h2 id="behavioral_design_pattern_title">Behavioral Design Patterns</h2>
				<p>A behavioral design pattern is about the assignments of responsabilies between the objects.</p>
				<p>Wikipedia says :</p>
				<blockquote>In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication.</blockquote>
				<h3 id="chain_of_responsability_ttl">Chain of Responsibility</h3>
				<p>Wikipedia says :</p>
				<blockquote>In object-oriented design, the Chain of Responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain.</blockquote>
				<p>In plain words, the Chain of Responsibility pattern handles a chain of objects. It's handle a request from one and manage the chain from object to object until the response.</p>
				<p>Real world example :<p>
				<p>Imagine you apply to a job in the military forces, you have to respond to some criterias like, have passed with success the test, have passed an interview with a recruiter and have an empty criminal record. If you apply to a job, a person will vérify all of this criterias and will call the good interlocutor for each of them (police to check the criminnal record, the recruiter for his opinion after the interview and the administration to get the result of the test).</p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
public abstract class ApplicationManager
{
	protected ApplicationManager Successor;
	
	public void SetSuccessor(ApplicationManager successor)
	{
		Successor = successor;
	}
	
	public abstract void ProcessRequest(string personName);
}

public class TestResultApplicationManager : ApplicationManager
{
	public override void ProcessRequest(string personName)
	{
		if(!HasPassed(personName))
		{
			Console.WriteLine("You need to pass the test");
			Return;
		}
		
		if(!IsApprouved(personName))
		{
			Console.WriteLine("Rejected");
			Return;
		}
		
		Console.WriteLine("The write test application department approved the application of " + personName);
		
		if(Successor != null)
			Successor.ProcessRequest(personName);
	}
	
	private bool HasPassed(string personName)
	{
		// Check if this person has passed the test
	}
	
	private bool IsApprouved(string personName)
	{
		// Check if this person succeed or failed
	}
}

public class InterviewApplicationManager : ApplicationManager
{
	public override void ProcessRequest(string personName)
	{
		if(!HasPassed(personName))
		{
			Console.WriteLine("You need to pass the interview");
			Return;
		}
		
		if(!IsApprouved(personName))
		{
			Console.WriteLine("Rejected");
			Return;
		}
		
		Console.WriteLine("The interview application department approved the application of " + personName);
		
		if(Successor != null)
			Successor.ProcessRequest(personName);
	}
	
	private bool HasPassed(string personName)
	{
		// Check if this person has passed an interview
	}
	
	private bool IsApprouved(string personName)
	{
		// Check if the recruiter approved the applicant or not
	}
}

public class PhysicalTestApplicationManager : ApplicationManager
{
	public override void ProcessRequest(string personName)
	{
		if(!HasPassed(personName))
		{
			Console.WriteLine("You need to pass the physical test");
			Return;
		}
		
		if(!IsApprouved(personName))
		{
			Console.WriteLine("Rejected");
			Return;
		}
		
		Console.WriteLine("The physical test application department approved the application of " + personName);
		
		if(Successor != null)
			Successor.ProcessRequest(personName);
	}
	
	private bool HasPassed(string personName)
	{
		// Check if this person has passed an interview
	}
	
	private bool IsApprouved(string personName)
	{
		// Check if the recruiter approved the applicant or not
	}
}

public class PoliceApplicationManager : ApplicationManager
{
	public override void ProcessRequest(string personName)
	{
		if(HasCriminalRecord(personName))
		{
			Console.WriteLine("Rejected");
			Return;
		}
		
		Console.WriteLine("The Police approved the application of " + personName);
		
		if(Successor != null)
			Successor.ProcessRequest(personName);
	}
	
	private bool HasCriminalRecord(string personName)
	{
		// Check if the applicant has a criminal record
	}
}
</code></pre>
<pre><code class="csharp">
  class MainApp
  {
    &#47;&#47;&#47;&#32;&#60;summary&#62;
    &#47;&#47;&#47;&#32;Entry point into console application.
    &#47;&#47;&#47;&#32;&#60;&#47;summary&#62;
    static void Main()
    {
	  ApplicationManager police = new PoliceApplicationManager();
	  ApplicationManager test = new TestApplicationManager();
	  ApplicationManager pysicalTest = new PhysicalTestApplicationManager();
	  ApplicationManager interview = new InterviewApplicationManager();
	  
	  police.SetSuccessor(test);
	  test.SetSuccessor(pysicalTest);
	  pysicalTest.SetSuccessor(interview);
	  
	  string personName = "Adrien Torris";
	  police.ProcessRequest(personName);
 
      // Wait for user
      Console.ReadKey();
    }
  }
</code></pre>
				<!--<p>When to use it ?<p>
				<p></p>-->
				<h3 id="command_ttl">Command</h3>
				<p>Wikipedia says :</p>
				<blockquote>In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters.</blockquote>
				<p>In plain words, a command pattern encapsulates a method call as an object.</p>
				<p>Real world example :<p>
				<p></p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
</code></pre>
				<p>When to use it ?<p>
				<p></p>
				<!--
				<h3></h3>
				<p>Wikipedia says :</p>
				<blockquote></blockquote>
				<p>In plain words, </p>
				<p>Real world example :<p>
				<p></p>
				<p>Programmatic example :<p>
<pre><code class="csharp">
</code></pre>
				<p>When to use it ?<p>
				<p></p>
				-->
				<div id="crdny">February 26, 2017</div>
				<div id="tags_wrapper">
					<ul>
						<li>Design Patterns</li>
						<li>Design Pattern</li>
						<li>Simple Factory</li>
						<li>Factory Method</li>
						<li>Abstract Factory</li>
					</ul>
				</div>
				<div id="refs_wrapper">
					<ul>
						<!--<li><a href="" title="" target="_Blank"></a></li>
						<li><a href="" title="" target="_Blank"></a></li>-->
					</ul>
				</div>
            </div>
			<footer>
			</footer>
		</div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js" type="text/javascript"></script>
		<script src="/wwwroot/js/Infra.js" type="text/javascript"></script>
		<link type="text/css" rel="stylesheet" href="/wwwroot/lib/highlight/styles/vs.css" />
		<script type="text/javascript" src="/wwwroot/lib/highlight/highlight.pack.js"></script>
		<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85948839-1', 'auto');
  ga('send', 'pageview');

</script>
	</body>
</html>